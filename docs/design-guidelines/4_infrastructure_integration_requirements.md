# Инфраструктура: требования к интеграции

Этот раздел фиксирует правила работы с Postgres, Redis, RabbitMQ, конфигурацией и внешними API.
Главная идея: инфраструктура — деталь, и она должна быть инкапсулирована.

## PostgreSQL: правила работы

Проектирование и миграции:
- Схема отражает доменную модель, ограничения задаются на уровне БД.
- Любые изменения схемы — через миграции (не руками в проде).
- Индексы и внешние ключи — осознанно, под реальные запросы.

Доступ к БД:
- Использовать пул соединений, корректно закрывать ресурсы.
- Транзакции — минимально возможной длительности.
- SQL параметры — только через placeholders, никаких строковых конкатенаций.

Репозитории:
- Весь SQL и доступ к БД инкапсулируется в repository-слое.
- Репозиторий возвращает доменно-осмысленные ошибки (`not found`, `conflict`, `temporary unavailable`).
- Доменные сервисы не знают про SQL/pgx/ORM.

Наблюдаемость:
- метрики по времени запросов и числу ошибок,
- трейсы (спаны) на ключевые DB операции.

Анти-паттерны:
- shared DB без владельца,
- бизнес-логика в SQL,
- транзакции вокруг сетевых вызовов.

## Redis: правила работы

Назначение:
- кеширование,
- временные данные,
- лёгкие механизмы синхронизации (с осторожностью),
- pub/sub (только если не нужна гарантированная доставка).

Правила кеша:
- Redis не является источником правды (source of truth).
- У ключей должен быть TTL (по умолчанию — да).
- Ключи имеют префиксы: `<domain>:<entity>:<id>` (например, `user:profile:123`).

Сериализация:
- выбрать единый формат (JSON или protobuf/msgpack) и не смешивать хаотично.

Надёжность:
- учитывать cache stampede (защититься через singleflight/локи при необходимости),
- не использовать Redis Pub/Sub для критичных задач (для этого RabbitMQ).

Метрики:
- hit/miss,
- latency операций,
- размер кеша/количество ключей (косвенно).

## RabbitMQ: правила работы

Модель сообщений:
- Сообщение — событие или задача, с чёткой схемой и версией.
- Сообщения должны быть **идемпотентны** (повторная обработка не ломает систему).

Публикация:
- при ошибках публикации — логировать и (при необходимости) ретраить,
- важные сообщения — с подтверждениями (publisher confirms),
- задавать `message_id` и correlation-id (если есть цепочка операций).

Потребление:
- управлять prefetch (Qos),
- корректно ack/nack,
- контролируемые ретраи:
    - временные ошибки → retry,
    - необратимые → DLQ.

DLQ:
- для важных очередей обязательно настраивать dead-letter механизм,
- хранить причину отказа (в заголовках/логах).

Наблюдаемость:
- метрики длины очереди, скорости обработки, ошибок,
- трейсы/логи с message_id.

## Секреты и конфигурация

Правила:
- конфигурация сервиса задаётся через env/конфиг и управляется окружением (K8s ConfigMap/Secret, Vault и т.п.);
- секреты никогда не хардкодятся и не коммитятся в репозиторий;
- логирование конфигурации допускается только без секретов (пароли/токены маскировать).

Практика:
- единая структура Config для сервиса,
- валидировать конфиг при старте (fail fast),
- значения по умолчанию — только безопасные и оправданные.

## Внешние API: интеграции

Правила:
- любой внешний API инкапсулировать в отдельном клиенте/адаптере (infrastructure слой),
- таймауты обязательны,
- ретраи — с экспоненциальной паузой и джиттером,
- лимиты запросов (rate limit) учитывать и уважать,
- ошибки внешних API маппить в доменные ошибки (temporary/permanent).

Безопасность:
- ключи и токены — только из секретов,
- чувствительные payload не логировать,
- ответы логировать выборочно (для дебага, без персональных данных).

## CI/CD, образы и окружения

Правила:
- каждый сервис имеет Dockerfile и воспроизводимую сборку,
- теги образов версионируются (commit sha / semver / release),
- `services.yaml` (или аналог) — источник правды для того, что деплоится и куда.

Окружения:
- dev/staging/prod должны отличаться только конфигом, а не кодом.
- сервисы из `services/dev/*` не включаются в prod.
- проверять совместимость контрактов (proto) на этапе CI (lint + breaking changes).
