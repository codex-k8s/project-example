# Сервисы: требования к проектированию

Цель: все сервисы одинаково устроены “снаружи”, имеют ясные доменные границы, стандартизированное взаимодействие и observability “из коробки”.

## Сервис: ответственность, имя и размещение

Имена:
- `kebab-case`.
- Имя отражает домен/роль; технологии в имени — только если это и есть домен (напр. “pdf”).

Размещение:
- `services/<zone>/<service-name>/`, где `<zone>` ∈ `internal|external|staff|jobs|dev`.

Правила ответственности:
- `internal`: бизнес-логика + владение данными.
- `external`/`staff`: thin-edge (валидация, authn/authz, маршрутизация, агрегация; без доменных правил).
- `jobs`: cron/worker/consumer, без публичного API.
- `dev`: только dev, отключено в prod окружениях.

Мини-документация сервиса:
- В каждом сервисе обязателен краткий `README.md`: назначение, входы/выходы (HTTP/gRPC/queue), ключевые env.

## Выбор протокола: HTTP/REST, gRPC, WebSocket, очередь

### gRPC (внутренний синхронный протокол)
Правила:
- Внутренние sync-вызовы сервис-сервис.
- Контракты в `proto/`; изменения версионируемы и обратно совместимы.
- Ошибки маппятся в gRPC status codes (единым правилом) и документируются.

### HTTP/REST (внешний интерфейс)
Правила:
- Внешние клиенты/браузеры/интеграции.
- Версионирование (`/api/v1/...`), корректные HTTP status codes, единый формат ошибок.
- Для public endpoints обязательны auth и rate limiting.

### WebSocket (real-time)
Правила:
- Real-time push/двунаправленность.
- Фиксированный формат сообщений (тип + payload), ping/pong, таймауты, лимиты.
- Масштабирование: sticky sessions или broker.

### RabbitMQ (асинхронно)
Правила:
- Async задачи/события/интеграции; слабая связность; устойчивость к сбоям.
- Идемпотентность, контролируемые ретраи (лимит+DLQ), `message_id`/correlation-id для важных цепочек.

## Внутренняя структура сервиса и слои

Слои (идея): `transport` (вход/выход) -> `application` (use-cases/оркестрация) -> `domain` (правила/модели); `infrastructure` (БД/кеш/очереди/внешние клиенты) подключается снаружи.

### Рекомендуемый каркас Go-сервиса (пример)
Внутри `services/<zone>/<service-name>/`:

- `cmd/<service-name>/main.go` — тонкий вход.
- `internal/app/` — composition root + graceful shutdown.
- `internal/transport/{http,grpc,ws}/` — handlers/registration без бизнес-логики.
- `internal/service/` — бизнес-логика.
- `internal/repository/postgres/`, `internal/cache/redis/`, `internal/mq/rabbit/` — адаптеры инфраструктуры.
- `internal/observability/` — подключение логов/метрик/трейсов (или через `libs/*`).
- Опционально: `api/` (OpenAPI/примеры), `migrations/` (если рядом).

Запрещено:
- доменная логика в `transport/*`,
- прямые импорты драйверов БД из домена,
- “общие DTO” без чёткой границы (смешение внешних/внутренних моделей).

## Нефункциональные требования к каждому сервису

Обязательное:
- Health: `/health/livez` (process alive), `/health/readyz` (готовность + критичные зависимости).
- Metrics: `/metrics` (Prometheus).
- Логи: структурированные в stdout/stderr; без секретов/PII.
- Трейсинг: OpenTelemetry + корректная пропагация контекста.
- Ошибки: оборачивать контекстом, не “глотать”, корректно маппить в HTTP/gRPC, не логировать секреты.
- Graceful shutdown (серверы/коннекты закрываются корректно).
- Конфигурация: только env/конфиг; никаких хардкодов секретов/адресов.
- Безопасность: `external|staff` = authn/authz; staff = аудит; external = rate limiting; `internal|jobs` = сетевые ограничения.
- Производительность: stateless по умолчанию, ресурсы/лимиты, таймауты на внешние вызовы.
