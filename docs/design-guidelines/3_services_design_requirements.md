# Сервисы: требования к проектированию

Этот раздел описывает, как проектировать и реализовывать сервисы (Go/Python/Vue3-TS), включая выбор протоколов, 
структуру кода и эксплуатационные требования.

Базовые ожидания:
- сервисы однотипны по каркасу,
- доменные границы ясны,
- взаимодействие стандартизировано (gRPC/HTTP/очереди),
- observability встроена по умолчанию.

## Сервис: ответственность, имя и размещение

Имена:
- Используйте **kebab-case**: `user-service`, `file-service`, `staff-portal`.
- Имя должно отражать домен/роль, а не технологию (`pdf-service` допустимо, если домен = PDF).

Размещение:
- Все сервисы лежат в `services/<zone>/<service-name>/`, где `<zone>` ∈ `{internal, external, staff, jobs, dev}`.

Правила ответственности:
- Доменные сервисы (обычно `internal`) содержат бизнес-логику и владеют данными.
- Edge-сервисы (`external`, `staff`) — thin: валидация, аутентификация, маршрутизация, агрегация.
- Jobs (`jobs`) — автономные задачи: cron/worker, без публичного API.
- Dev (`dev`) — только для разработки, не должен быть включён в prod окружениях.

Мини-документация сервиса:
- В каждой папке сервиса должен быть краткий `README.md` (назначение + входы/выходы + переменные окружения).

## Выбор протокола: HTTP/REST, gRPC, WebSocket, очередь

### gRPC (внутренний синхронный протокол)
Использовать когда:
- сервис-сервис взаимодействие внутри кластера,
- требуется типизация, контрактность и производительность.

Правила:
- контракты в `proto/`,
- изменения версионируются и совместимы,
- ошибки маппятся в gRPC status codes и документируются.

### HTTP/REST (внешний интерфейс)
Использовать когда:
- API для внешних клиентов,
- совместимость с браузерами/интеграциями.

Правила:
- версионирование (`/api/v1/...`),
- нормальные HTTP status codes,
- единый формат ошибок,
- rate limiting и auth обязательны для public endpoints.

### WebSocket (real-time)
Использовать когда:
- нужен push-канал и двунаправленное общение,
- частые обновления состояния.

Правила:
- фиксированный формат сообщений (тип + payload),
- ping/pong, таймауты, лимиты соединений,
- продумать горизонтальное масштабирование (sticky sessions или broker).

### RabbitMQ (асинхронно)
Использовать когда:
- фоновые задачи, события, интеграции,
- нужна слабая связность и устойчивость к временным сбоям.

Правила:
- события идемпотентны,
- ретраи контролируемы (DLQ/лимит попыток),
- важные сообщения имеют `message_id`/correlation-id.

## Внутренняя структура сервиса и слои

Независимо от языка, структура должна отражать слои:
- `transport` (HTTP/gRPC/WS/consumers) — вход/выход
- `application` (use-cases) — сценарии, оркестрация
- `domain` — бизнес-правила и модели
- `infrastructure` — БД/кеш/очередь/внешние клиенты

### Рекомендуемый каркас Go-сервиса (пример)
Внутри `services/<zone>/<service-name>/`:

- `cmd/<service-name>/main.go`  
  Тонкий вход: инициализация и запуск.

- `internal/app/`  
  Composition root: сборка зависимостей, запуск серверов, graceful shutdown.

- `internal/transport/http/`  
  HTTP роуты/handlers (без бизнес-логики).

- `internal/transport/grpc/`  
  gRPC server реализации/регистрация.

- `internal/transport/ws/`  
  WebSocket gateway/handlers (если нужно).

- `internal/service/`  
  Бизнес-логика.

- `internal/repository/postgres/`  
  Реализация репозиториев для Postgres.

- `internal/cache/redis/`  
  Реализация кеша через Redis.

- `internal/mq/rabbit/`  
  Паблишер/консьюмер RabbitMQ.

- `internal/observability/`  
  логгер, метрики, трейсинг (или подключение общих `libs/*`).

Дополнительно:
- `api/` (опционально) — если храните OpenAPI или примеры запросов.
- `migrations/` (опционально) — если миграции живут рядом с сервисом.

Запрещено:
- доменная логика в `transport/*`,
- прямые импорты драйверов БД из домена,
- “общие DTO” без чёткой границы (смешение внешних/внутренних моделей).

## Нефункциональные требования к каждому сервису

Обязательное:
- **Health endpoints**:
    - liveness: процесс жив (`/health/livez`)
    - readiness: готов обслуживать (`/health/readyz`) с проверкой критичных зависимостей
- **Метрики**: `/metrics` для Prometheus.
- **Логи**: структурированные, в stdout/stderr.
- **Трейсинг**: OpenTelemetry, корректная пропагация контекста.
- **Ошибки**:
    - оборачивать контекстом,
    - не “глотать”,
    - корректно маппить на HTTP/gRPC коды,
    - не логировать секреты.

Рекомендуемое:
- **Graceful shutdown**: корректно останавливать серверы и закрывать подключения.
- **Конфигурация**: только через env/конфиг, без хардкода секретов и адресов.
- **Безопасность**:
    - external/staff: authn/authz обязателен,
    - аудит действий для staff,
    - rate limiting для external,
    - ограничение сетевого доступа для internal/jobs.
- **Производительность**:
    - stateless сервисы по умолчанию,
    - лимиты ресурсов,
    - таймауты на внешние вызовы.

