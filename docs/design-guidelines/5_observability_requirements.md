# Observability: требования

Observability = логи + трейсы + метрики.
Все сервисы обязаны “встраиваться” в эту систему по умолчанию.

## Логирование

Правила:
- логи структурированные (JSON или key=value),
- уровни логов использовать по назначению (DEBUG/INFO/WARN/ERROR),
- не логировать секреты и чувствительные данные,
- включать корреляционные идентификаторы:
    - `trace_id` (обязательно),
    - `span_id` (желательно),
    - `request_id`/`message_id` (по ситуации).

Практика:
- middleware/interceptor логируют входящие запросы/вызовы,
- бизнес-логика логирует только исключительные ситуации (без шума),
- ошибки оборачиваются контекстом (`operation`, `entity_id`, `cause`).

## Трассировки (OpenTelemetry + Jaeger)

Правила:
- все входящие HTTP/gRPC/очереди операции создают/продолжают trace;
- контекст трассировки прокидывается между сервисами;
- ключевые внешние вызовы (DB, gRPC, HTTP, queue) — отдельные спаны.

Практика:
- корректные имена спанов:
    - HTTP: `HTTP <method> <route>`
    - gRPC: `<Service>/<Method>`
    - DB: `DB <operation> <table>` (или имя репозиторного метода)
- атрибуты спанов:
    - http.*, rpc.*, db.*, messaging.* (по семантическим конвенциям)
- sampling задаётся окружением (в dev можно 100%, в prod — выборочно).

## Метрики (Prometheus)

Правила:
- каждый сервис отдаёт `/metrics`,
- минимум метрик:
    - количество операций,
    - количество ошибок,
    - длительность операций (гистограммы),
    - технические метрики runtime,
- лейблы ограничивать (избегать высокой кардинальности).

Практика:
- иметь единый нейминг метрик и лейблов во всей системе,
- добавлять бизнес-метрики там, где это помогает продукту и эксплуатации,
- при возможности связывать метрики с trace (exemplars) для “метрики → трейсы”.

