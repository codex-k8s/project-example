# Инфраструктура: требования к интеграции

Правила работы с Postgres/Redis/RabbitMQ/конфигом/внешними API. Инфраструктура — деталь и должна быть инкапсулирована (domain/service слои не знают про драйверы/SDK).

## PostgreSQL: правила работы

- Схема = отражение домена; ограничения (FK/unique/check) задаются в БД.
- Схема меняется только миграциями (не руками в prod). Миграции храним в `cmd/cli/migrations/*.sql`, запускаем goose из `cmd/cli`.
- Миграции goose: timestamp-префикс, секции `-- +goose Up/Down`.
- Индексы/FK — осознанно под реальные запросы.
- Доступ: пул соединений; ресурсы закрывать; транзакции минимальной длительности.
- SQL только с placeholders (без конкатенаций/инъекций).
- SQL живёт в repository-слое; repo возвращает доменно-осмысленные ошибки (not found/conflict/temporary unavailable); домен не знает про SQL/pgx/ORM.
- В repo-реализациях на `pgx` используем хелперы маппинга (`pgx.RowToStructByName`, `pgx.CollectRows`, `pgx.CollectOneRow`), а не прямой `Scan`.
- Реализация repo на Postgres: `internal/repository/postgres/...`; интерфейсы repo: `internal/domain/repository/...`.
- Запрещено: SQL как строка в Go-коде. Требование:
  - каждый запрос в отдельном `internal/repository/postgres/<model>/sql/*.sql`;
  - загрузка только через `//go:embed`;
  - запросы имеют имя-комментарий `-- name: <model>__<operation> :one|:many|:exec`;
  - сложные запросы допускают шаблонизацию в `.sql` (например, `text/template` или аналог), с явными и безопасными параметрами.
- Observability: метрики latency/error + спаны на ключевые DB операции.
- Анти-паттерны: shared DB без владельца; бизнес-логика в SQL; транзакции вокруг сетевых вызовов.

## Redis: правила работы

Назначение:
- кеширование,
- временные данные,
- лёгкие механизмы синхронизации (с осторожностью),
- pub/sub (только если не нужна гарантированная доставка).

Правила кеша:
- Redis не source of truth.
- TTL по умолчанию обязателен.
- Ключи префиксировать: `<domain>:<entity>:<id>` (напр. `user:profile:123`).

Сериализация:
- Единый формат (protobuf).

Надёжность:
- Учитывать cache stampede (singleflight/локи/прогрев при необходимости).
- Redis Pub/Sub не использовать для критичных задач (для этого RabbitMQ).

Метрики:
- hit/miss, latency, (косвенно) размер/кол-во ключей, параметры пула.

## RabbitMQ: правила работы

Контракт:
- Все каналы/сообщения/версии для RabbitMQ описываются в AsyncAPI YAML: `api/server/asyncapi.yaml` (AMQP bindings: exchange/queue/routingKey и т.п.).

Модель сообщений:
- Сообщение = событие/задача с явной схемой и версией.
- Обязательна идемпотентность обработки.

Публикация:
- Ошибки публикации: логировать, при необходимости ретраить.
- Для важных сообщений использовать publisher confirms.
- Заполнять `message_id` и correlation-id (если есть цепочка).

Потребление:
- Настроить prefetch (QoS).
- Корректные ack/nack.
- Ретраи контролируемые: временные -> retry; необратимые -> DLQ.

DLQ:
- Для важных очередей DLQ обязателен; причину отказа сохранять (headers/логи).

Наблюдаемость:
- Метрики: длина очереди/скорость/ошибки; логи/трейсы с `message_id`.

## Секреты и конфигурация

Правила:
- Конфиг только через env/конфиг, управляемый окружением (K8s ConfigMap/Secret).
- Секреты не хардкодить и не коммитить.
- Логировать конфиг можно только без секретов (маскировать пароли/токены).
- Для сервисов с несколькими БД/кешами в одном кластере обязательны префиксы env для изоляции секретов:
  - сервис задаёт `ENV_PREFIX` (пример: `USERS_`);
  - Postgres креды: `${ENV_PREFIX}POSTGRES_USER`, `${ENV_PREFIX}POSTGRES_PASSWORD`, `${ENV_PREFIX}POSTGRES_DB`;
  - Redis креды/параметры: `${ENV_PREFIX}REDIS_PASSWORD` (и при необходимости `${ENV_PREFIX}REDIS_DB`).
- Новые переменные и секреты добавлять через `gh`:
  - `gh variable set VAR_NAME --env ai-staging --body "value"`
  - `echo "secret_value" | gh secret set SECRET_NAME --env ai-staging`
- секреты генерировать безопасно командой (openssl/random).
- секреты и переменные добавлять также в staging окружение.
- уже существующие секреты/переменные не менять.
- о созданныых в рамках PR секретах/переменных сообщать в описании PR, не раскрывая их значения.

Практика:
- Единая структура Config; валидация на старте (fail fast); дефолты только безопасные и оправданные.

## Внешние API: интеграции

Правила:
- Внешний API = отдельный клиент/адаптер (infrastructure слой).
- Таймауты обязательны.
- Ретраи: экспоненциальная пауза + jitter; учитывать rate limits.
- Ошибки маппить в доменную семантику (temporary/permanent).

Безопасность:
- Ключи/токены только из секретов; чувствительные payload не логировать; ответы логировать выборочно (debug) без персональных данных.

## CI/CD, образы и окружения

Правила:
- Каждый сервис: Dockerfile + воспроизводимая сборка.
- Теги образов версионировать (commit sha / semver / release).
- `services.yaml` — источник правды: что/куда деплоится. Используется `github.com/codex-k8s/codexctl`.
- Dev/AI окружения: сервисы запускаются с live-reload (Go: CompileDaemon, Vue: Vite) и монтируют workspace PVC с монорепо; код берётся из `CODE_ROOT` (внутри PVC), чтобы правки агента подхватывались без пересборки образов.

Окружения:
- dev/ai-staging/staging/prod отличаются только конфигом (не кодом).
- `services/dev/*` не включаются в prod.
