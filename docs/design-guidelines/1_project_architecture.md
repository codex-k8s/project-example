# Архитектура проекта

Цель архитектуры — обеспечить предсказуемое развитие системы, где:
- бизнес-логика изолирована от инфраструктуры и транспортов;
- сервисы слабо связаны, изменения локализуются в пределах домена;
- интерфейсы (API/события) типизированы и версионируемы;
- эксплуатация (деплой/наблюдаемость/конфигурация) стандартизирована.

Базовые принципы:
- микросервисная архитектура с доменными границами (DDD);
- слоистость и правило зависимостей (Clean Architecture);
- единый инвентаризационный файл сервисов и окружений (например, `services.yaml`);
- единый каркас директорий, чтобы все сервисы выглядели одинаково “снаружи”.

## Микросервисы и монорепозиторий

Подход:
- Система состоит из набора независимых сервисов, каждый отвечает за один ограниченный контекст (bounded context).
- Исходники всех сервисов и общих библиотек хранятся в одном репозитории (монорепозиторий), чтобы:
    - унифицировать правила разработки и структуры;
    - упрощать рефакторинг общих контрактов (proto) и библиотек;
    - снижать дублирование кода (DRY) за счёт `libs/`.

Правила:
- Сервис — единица деплоя и масштабирования. Нельзя “склеивать” два домена в один сервис ради удобства.
- Взаимодействие между сервисами — через:
    - **gRPC** (основной внутренний синхронный протокол),
    - **очередь** (RabbitMQ) для асинхронных событий/задач,
    - **HTTP/REST** для внешних API (или через gateway),
    - **WebSocket** для real-time каналов (по необходимости).
- Общая база данных между сервисами — исключение. Предпочтительно API/события вместо “shared DB”.
- Все изменения, влияющие на несколько сервисов (например, proto-контракты), делаются через общий источник правды (`proto/`) и автоматическую генерацию.

## Структура репозитория

Рекомендуемая структура верхнего уровня:

- `services.yaml`  
  Единый “инвентарь” сервисов и инфраструктуры:
    - список образов/версий,
    - список сервисов, их deploy-манифестов и зависимостей,
    - описания окружений (dev/staging/prod),
    - параметры деплоя (домен, хелсчеки, маршруты, ресурсы).

- `services/`  
  Все сервисы, сгруппированные по зоне доступа:
    - `services/internal/*`
    - `services/external/*`
    - `services/staff/*`
    - `services/jobs/*`
    - `services/dev/*`

- `libs/`  
  Переиспользуемые библиотеки (по языкам и назначению):
    - `libs/go/*`
    - `libs/python/*`
    - `libs/web/*` (если есть общие фронтенд-пакеты)

- `proto/`  
  Единый источник правды для gRPC/Protobuf контрактов:
    - `.proto` файлы,
    - правила версионирования,
    - скрипты генерации,
    - lint/breaking checks (желательно через Buf).

- `deploy/`  
  Общая инфраструктура (Postgres/Redis/RabbitMQ/Prometheus/Jaeger и т.п.), общие манифесты.

- `docs/`  
  Документация, включая `docs/design-guidelines/`.

- `scripts/`  
  Скрипты генерации, dev-утилиты, CI-хелперы.

- `.github/`  
  CI/CD workflows.

Соглашения:
- Имена директорий и сервисов — **kebab-case** (через дефис): `user-service`, `file-service`, `staff-portal`.
- Один сервис = одна папка `services/<zone>/<service-name>/`.
- Внутри сервисов придерживаться единого каркаса (см. раздел “Сервисы: внутренняя структура”).

## Зоны сервисов: internal / external / staff / jobs / dev

Сервисы разделяются по зоне доступа и режиму эксплуатации.

### `services/internal/`
Назначение:
- только внутреннее взаимодействие между сервисами (east-west traffic),
- не публикуются наружу (нет публичного ingress).

Правила:
- основной транспорт — gRPC и очередь,
- REST допускается только для технических эндпоинтов (health/metrics),
- доступ ограничен сетевыми политиками (K8s NetworkPolicy) и/или сервисной mesh-политикой.

Примеры:
- `services/internal/user-service/`
- `services/internal/file-service/`
- `services/internal/billing-service/`

### `services/external/`
Назначение:
- пользовательские API, доступные из интернета (через балансер/ingress),
- здесь обычно находятся gateway/BFF/edge-сервисы.

Правила:
- обязательны аутентификация/авторизация, rate limiting, аудит,
- REST и WebSocket — типичные транспорты,
- внутренние вызовы к доменным сервисам — gRPC.

Примеры:
- `services/external/public-api/`
- `services/external/websocket-gateway/`

### `services/staff/`
Назначение:
- сервисы для сотрудников (админки, бек-офис),
- доступ ограничен: VPN, SSO, IP allowlist и т.п.

Правила:
- доступ “извне” допускается, но строго ограниченный,
- обязателен аудит действий,
- отдельные роли/права, отдельные маршруты/домены.

Примеры:
- `services/staff/staff-portal/`
- `services/staff/admin-api/`

### `services/jobs/`
Назначение:
- фоновые воркеры, крон-джобы, периодические задачи,
- как правило, не имеют публичного API.

Правила:
- запускаются как K8s `CronJob` или `Deployment`-worker (consumer очереди),
- обязателен idempotency и корректные ретраи,
- health/metrics доступны (для мониторинга), но не публично.

Примеры:
- `services/jobs/reporting-job/`
- `services/jobs/data-cleanup-job/`
- `services/jobs/email-dispatcher/`

### `services/dev/`
Назначение:
- сервисы/утилиты только для разработчиков,
- не деплоятся в staging/prod.

Правила:
- должны быть явно выключены в prod окружениях через `services.yaml`,
- могут предоставлять удобные dev-интерфейсы (swagger, grpc-gateway, mocks).

Примеры:
- `services/dev/grpc-gateway-dev/`
- `services/dev/mock-external-api/`

## Границы сервисов и разделение ответственности

Правила:
- Каждый сервис отвечает за один доменный контекст и имеет ясную “причину для изменения”.
- Нельзя делать “service-олигарх”, который знает обо всём (анти-паттерн).
- Разделение по данным:
    - сервис владеет своими данными (owner),
    - другие сервисы получают данные через API/события (а не прямыми SQL-запросами).

Как выделять сервис:
- По бизнес-терминам и процессам, а не по таблицам/технологиям.
- По жизненному циклу изменений: если две части меняются независимо — это кандидаты на разные сервисы.
- По масштабированию: если требуется отдельное масштабирование — это кандидат на отдельный сервис.

Примеры доменных сервисов:
- `user-service` — пользователи, идентичность, профили (internal).
- `file-service` — загрузка/хранение/метаданные файлов (internal).
- `staff-portal` — интерфейс и API для сотрудников (staff).
- `public-api` — внешний BFF/gateway (external).
- `reporting-job` — периодический отчёт (jobs).

Запрещено:
- доменная логика в gateway-сервисах (external/staff должны быть thin-edge),
- “общие утилиты” внутри каждого сервиса вместо выноса в `libs/`,
- общие таблицы/схемы БД без явного владельца.
