# 7 — Запрещённые практики (анти-паттерны)

## Зачем
Эти подходы выглядят “быстрее”, но размывают границы, ломают контракт и создают хаос в логах.

1) Универсальная AppError-структура
    - смешивает уровни, разрастается, усложняет рефакторинг.  
      ✅ Вместо этого: обычные error + небольшой набор typed errors + маппинг на границе.

2) Логирование ниже границы
    - приводит к дублированию и шуму.  
      ✅ Вместо этого: возвращаем error наверх, логируем один раз на границе.

3) Транспортные коды в service/repo
    - HTTP: `echo.HTTPError` в сервисе; gRPC: `status.Error(codes.X)` в сервисе как основной паттерн.  
      ✅ Вместо этого: доменные typed errors (`NotFound`, `Validation` и т.п.).

4) Возврат клиенту `err.Error()`
    - утечка деталей (SQL, адреса, внутренние тексты).  
      ✅ Вместо этого: безопасное сообщение + логирование первопричины на границе.

5) Сравнение ошибок по строке  
   ✅ Только `errors.Is/As`.

6) Потеря первопричины
    - нет `%w` => невозможно нормально диагностировать.  
      ✅ Оборачиваем с `%w`, когда добавляем смысловой контекст.

7) “Пустое” оборачивание
    - `repo error: %w` без смысла ухудшает логи.  
      ✅ Обёртка = конкретный контекст (операция + параметры).

8) Зоопарк typed errors  
   ✅ Лучше универсальный `Validation{field,msg}`, чем десятки микротипов.

9) Sentinel errors с данными в тексте  
   ✅ Typed errors с полями + `errors.As`.

10) Формирование ошибок/ответов в каждом handler  
    ✅ Централизованный error handler/interceptor.

11) `panic` для ожидаемых сценариев  
    ✅ `panic` только для нарушения инвариантов (ошибка разработчика).

12) Логирование `context.Canceled` как ошибка  
    ✅ Обычно это нормальное поведение (клиент ушёл).

13) Отдавать клиенту “сырые” ошибки OpenAPI/валидатора  
    ✅ В prod только безопасный стабильный контракт.

14) gRPC: “любая ошибка = codes.Unknown/ Internal” без маппинга
- клиент теряет семантику (not found vs forbidden), автоматизация ломается.  
  ✅ Маппинг доменных ошибок в корректные `codes.*` на границе.
