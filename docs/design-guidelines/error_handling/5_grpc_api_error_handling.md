# 5 — gRPC API: единая обработка ошибок

## Зачем
Стандартизировать ошибки между внутренними сервисами: единые коды, единая точка логирования и маппинга, отсутствие утечки внутренних деталей.

## Чем gRPC отличается от HTTP
- gRPC возвращает результат как:
    - данные (reply) + `error`, который кодируется в **status code**;
- ошибки должны быть выражены в терминах `codes.*`, а не строк;
- у gRPC есть unary и streaming RPC — в streaming часть данных может быть отправлена до ошибки, но итоговый статус всё равно важен.

## Где “граница” в gRPC
Границей считается серверный слой, который:
- преобразует `error` в `status` (codes + message + details),
- решает, что видно клиенту,
- логирует неожиданные ошибки.

Практически это:
- **UnaryServerInterceptor** и **StreamServerInterceptor**;
- recovery interceptor для перехвата panic.

Сами gRPC handlers (методы сервиса):
- не логируют ошибки,
- не форматируют `status` как основной паттерн,
- возвращают доменные ошибки/обычные ошибки наверх.

## Panic/recover в gRPC
Обязательное:
- паники в gRPC должны быть перехвачены recovery interceptor’ом,
- клиент получает `codes.Internal`,
- паника логируется на границе с stacktrace.

## Контракт ошибок для gRPC клиентов
Клиенту нужен стабильный сигнал:
- **status code** — основной контракт для ветвления,
- `message` — безопасный текст (не `err.Error()` изнутри),
- `details` — опционально, структурированные детали (валидация и т.п.), если это принято.

## Маппинг доменных ошибок -> gRPC codes (рекомендуемый минимум)
- Validation -> `codes.InvalidArgument`
- Unauthorized -> `codes.Unauthenticated`
- Forbidden -> `codes.PermissionDenied`
- NotFound -> `codes.NotFound`
- Conflict -> обычно `codes.FailedPrecondition`  
  (иногда: `AlreadyExists` для дублей, `Aborted` для конкурентных конфликтов — выберите и зафиксируйте правило)
- Остальное -> `codes.Internal`

## Что логируется в gRPC
Логируем (как error):
- неожиданные ошибки, которые уходят как `Internal` (и близкие к нему),
- паники,
- системные сбои.

Не логируем как error:
- ожидаемые доменные ошибки (валидация/not found/forbidden и т.п.),
- `context.Canceled`,
- дедлайны — чаще warn (если надо).

## Валидация входа
Уровни:
- **schema-level** (то, что задано proto типами) — базово;
- **business-level** — в service/use-case слое, возвращает `errs.Validation`.

Опционально:
- protoc/buf-валидаторы (если используется) должны переводить результат в `errs.Validation` или в `codes.InvalidArgument` на границе.

## Когда допустимо вернуть status.Error прямо из handler’а
Редко, если:
- ошибка специфична gRPC и не имеет доменной семантики,
- не планируется переиспользование в HTTP,
- код/детали не должны проходить общий доменный маппинг.

По умолчанию: возвращаем доменные ошибки и доверяем interceptor’у.
