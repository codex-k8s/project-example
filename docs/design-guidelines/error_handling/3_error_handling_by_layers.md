# 3 — Правила по слоям: кто что делает с ошибками

## Зачем
Снять неоднозначность “где обрабатывать, где логировать, где маппить” и стандартизировать ревью.

## Архитектурная цепочка
`Client -> Repository -> Service -> Transport handlers (HTTP/gRPC) -> Error boundary`

## Универсальные правила для всех слоёв
- Ошибка **возвращается наверх**, а не “чинится” локально без причины.
- Ниже границы ошибки **не логируются**.
- Контекст добавляется через `fmt.Errorf("...: %w", err)` (если он действительно добавляет смысл).
- Никакого форматирования клиентского ответа вне границы.

---

## Client layer (внешние системы/SDK)
Можно:
- возвращать `error` с контекстом (какой вызов/операция упали);
- иногда нормализовать внешнюю ошибку в доменную (например, 404 внешней системы -> `errs.NotFound`).

Нельзя:
- логировать ошибки;
- возвращать HTTP/gRPC статусы или транспортные структуры;
- формировать клиентский ответ.

---

## Repository layer (БД/хранилища)
Должен:
- переводить инфраструктурные ситуации в доменные (например, no rows -> `errs.NotFound`);
- добавлять контекст (операция + ключевые параметры) через `%w`;
- возвращать ошибку наверх без логов.

Запрещено:
- терять первопричину (без `%w`);
- отдавать “обобщённые” строки вместо доменной семантики;
- использовать транспортные ошибки/коды.

---

## Service layer (бизнес-логика)
Должен:
- реализовать бизнес-валидацию и вернуть `errs.Validation` (или аналог);
- нормализовать ошибки разных источников к доменной семантике;
- добавлять смысловой контекст, если это помогает диагностике.

Запрещено:
- принимать решения про HTTP/gRPC коды;
- создавать транспортные ошибки (`echo.HTTPError`, `status.Error(...)`) как основной механизм;
- логировать ошибки.

---

## Transport handlers (HTTP handler / gRPC handler)
Роль:
- тонкий слой, вызывает сервис и возвращает `error` “как есть”.

Должен:
- не дублировать маппинг и форматирование;
- не логировать ошибки;
- передавать `ctx` и возвращать `err` наверх.

---

## Параллельность внутри слоя
Если слой запускает несколько задач:
- рабочие goroutines возвращают `error`;
- есть единая точка fan-in (агрегация);
- логирование — после агрегации, на границе.

---

## Деградация и фоллбэки (важно)
Если принято решение вернуть **успешный** (но деградированный) результат:
- ошибку **не** прокидываем наверх;
- деградацию логируем **там, где принято решение о фоллбэке** (см. исключения).

---

## Типовые нарушения
- логирование в repo/service -> дубли и потеря контекста;
- транспортные коды в service -> переиспользование ломается;
- `err.Error()` клиенту -> утечка внутренних деталей;
- отсутствие `%w` -> потеря первопричины;
- ручное форматирование ответов в каждом handler -> расползание контракта.
