# Модель ошибок и границы ответственности

## Зачем
Зафиксировать единый способ думать об ошибках в Go-сервисе: где они рождаются, где форматируются для клиента и где логируются.

## Базовые определения
- **Ошибка** — это значение `error`, сигнализирующее о неуспешной операции.
- Ошибка может содержать **контекст причины** (через оборачивание), но **не является**:
    - HTTP-ответом,
    - gRPC-статусом для клиента,
    - лог-записью,
    - “универсальным объектом” со статусами/кодами/деталями.

Типы сценариев:
- **фатальная**: запрос/операция завершается ошибкой;
- **деградация**: система сознательно переходит на фоллбэк и продолжает работу (см. исключения).

## Почему избегаем универсальных AppError-структур
“Единая структура ошибки” почти всегда:
- смешивает домен, транспорт и инфраструктуру;
- разрастается полями (status/code/details/meta/cause…);
- делает контракты неявными;
- ухудшает тестирование и масштабирование.

Вместо этого:
- используем обычные `error` + контекст через `%w`;
- держим **малый набор** доменных typed errors;
- маппинг на формат ответа делаем **только на границе**.

## Слои и границы (слоистая модель)
Модель сервиса:
`Client -> Repository -> Service -> Transport (HTTP handler / gRPC handler) -> Error boundary`

Роли:
- **Client**: общение с внешними системами/SDK, нормализация некоторых ошибок (без транспорта клиенту).
- **Repository**: БД/хранилища, перевод инфраструктурных ошибок в доменную семантику.
- **Service**: бизнес-правила и бизнес-валидация, сбор/нормализация ошибок.
- **Transport handlers**: тонкий слой, вызывает сервис и возвращает `error`.

## Что считается “границей”
Граница — точка, где:
- известен контекст запроса (метод/endpoint, user/request-id, trace);
- решается, **что** именно отдать клиенту (HTTP / gRPC);
- выполняется **логирование** (по правилам).

Типичные границы:
- единый обработчик ошибок HTTP (error handler/middleware);
- gRPC interceptors (unary/stream) — единая точка маппинга + логирования;
- entry-point фонового процесса/джобы;
- точка агрегации параллельных задач (fan-in).

## Главное правило
- **Логи ошибок пишем на границе**, ниже — не логируем.
- Нижние слои добавляют **контекст**, но не решают **формат ответа**.

## Итог
Минимализм лучше “универсальности”:
- меньше типов, больше дисциплины;
- один контракт на границе;
- предсказуемость для разработчиков и клиентов.
