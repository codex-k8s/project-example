# 6 — Параллельность, goroutines и ошибки

## Зачем
Чтобы параллельный код не “ломал” стандарт: одна точка логирования, сохранение контекста и отсутствие silent-crash.

## Главная мысль
В параллельном коде **граница — fan-in (агрегация)**, а не тело goroutine.

Правила:
- рабочие goroutines не логируют и не форматируют ответ;
- goroutines возвращают `error` в агрегатор;
- агрегатор возвращает итоговую ошибку наверх (логирование — на границе сервиса).

## Базовый паттерн: errgroup
Рекомендуется `errgroup.WithContext`:
- отмена контекста при первой ошибке,
- меньше утечек горутин,
- проще сопровождать.

Каждая goroutine добавляет **осмысленный** контекст (`"load profile: %w"`), без “service error: %w”.

## Cancel-on-first vs Collect-all
- Cancel-on-first (по умолчанию): когда нужен результат целиком или никак.
- Collect-all: когда нужен полный список проблем (отчёт/пакетная обработка).
  Для collect-all можно собирать список ошибок и объединять (например, `errors.Join`).

## Паники внутри goroutine
Проблема: panic в goroutine может не попасть в middleware/interceptor.
Правило: важные goroutines должны быть защищены `recover()` и конвертировать panic в `error`.

## Параллельность в HTTP/gRPC
- В HTTP: ошибки агрегируются до возврата из handler, логируются центральным HTTP error handler.
- В gRPC: ошибки агрегируются до возврата из метода, логирование/маппинг делает interceptor.

## Фоновые задачи / воркеры
- Entry-point job’ы считается границей: именно там логирование итоговой ошибки.
- Внутри job — те же правила: goroutines возвращают ошибки, fan-in агрегирует.

## Fire-and-forget (опасно)
Допустимо только если:
- результат действительно не важен,
- потеря ошибки не критична,
- panic обработан локально.
  По умолчанию fire-and-forget не рекомендуется.
