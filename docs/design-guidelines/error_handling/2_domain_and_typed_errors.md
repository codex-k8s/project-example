# 2 — Доменные ошибки и typed errors

## Зачем
Сделать ошибки “понятными домену” и дать границе возможность стабильно маппить их в HTTP/gRPC без хаоса из кодов и строк.

## Что такое доменная ошибка
Доменная ошибка:
- выражена в терминах предметной области;
- не зависит от транспорта (HTTP/gRPC);
- ожидаема и может управлять ветвлением логики.

Примеры доменных ситуаций:
- “не найдено”,
- “не авторизован”,
- “доступ запрещён”,
- “бизнес-валидация не прошла”,
- “конфликт/несовместимое состояние”.

Не является доменной:
- SQL/сетевая/таймаут ошибка как таковая,
- HTTP/gRPC коды,
- формат ответа или логирование.

## Typed error: что это
Typed error — это тип, реализующий `error`, который:
- позволяет отличать классы ошибок через `errors.As`;
- может хранить структурированные данные (например, `field`, `entity`, `id`).

Ограничения:
- в typed error **не** кладём HTTP/gRPC коды;
- typed error **не** форматирует ответ;
- typed error **не** логируется в месте создания.

## Где объявлять typed errors
- Все доменные typed errors — в **одном месте** (например, `internal/domain/errs`).
  Это снижает циклические зависимости и предотвращает “зоопарк типов”.

Запрещено:
- объявлять типы в transport-слое,
- плодить тип “под один endpoint”.

## Минимальный рекомендуемый набор (пример)
- `Validation{Field, Msg}`
- `NotFound{Entity, ID}`
- `Forbidden{Msg}`
- `Unauthorized{Msg}`
- `Conflict{Msg}`

Принцип: типов мало, данные — только если реально нужны, сообщения не считаем контрактом.

## Когда typed error нужен
Используем typed error, если:
- на границе требуется ветвление по типу;
- ошибка ожидаема и влияет на поведение клиента;
- нужны структурированные детали (например, поле валидации).

Не используем typed error, если:
- ошибка сугубо техническая и просто “пробрасывается наверх”;
- ветвление по типу не нужно;
- формат ответа не меняется.

## Typed errors vs sentinel errors
- Sentinel (`var ErrX = errors.New(...)`) годится как “маркер”, но не хранит данные и часто толкает к парсингу строк.
- Typed error предпочтительнее: безопасно извлекается через `errors.As`, может нести данные.

## Как проверять typed errors
- Проверка **только** через `errors.As`.
  Запрещено:
- сравнение по строке,
- `reflect.TypeOf`,
- небезопасные type-assertion без `errors.As` (кроме узких случаев).

## Что можно “показать клиенту”
Typed error может содержать данные, но решение:
- какие поля публичные,
- какие детали вернуть,
  принимается **на границе** (HTTP/gRPC), а не в `Error()`.

### Пример логики
- В сервисе: вернуть `errs.Validation{Field:"limit", Msg:"must be 1..100"}`
- На границе:
    - HTTP: 400 + field (и безопасные details при необходимости)
    - gRPC: `InvalidArgument` + optional structured details (например, field)

## Частые ошибки
- делать typed error для каждой мелочи;
- прятать бизнес-логику в `Error()`;
- смешивать typed error с транспортными кодами;
- отдавать typed error как готовый ответ.
