# Принципы проектирования

Этот документ фиксирует обязательные принципы, применимые ко всем языкам (Go, Python, TypeScript/Vue):
- DDD: доменные модели и границы контекстов;
- SOLID: устойчивость к изменениям, модульность;
- DRY: отсутствие дублирования;
- KISS: простота решений;
- Clean Architecture: слои и зависимость “снаружи внутрь”.

Главное правило: **архитектура должна помогать развитию продукта**, а не быть самоцелью.

## DDD (Domain-Driven Design)

Правила:
- Выделяйте bounded contexts и не смешивайте термины/модели разных доменов.
- Используйте ubiquitous language — термины домена должны быть в коде и API.
- Доменные правила первичны: инфраструктура (БД, очередь, HTTP) — вторична.

Практика:
- Доменная логика живёт в доменном/сервисном слое и не зависит от SQL/HTTP/ORM.
- Граница контекста — через API/события, а не через shared-код и shared-таблицы.

Пример:
- `user-service` владеет моделью пользователя и правилами изменения профиля.
- `file-service` владеет моделью файла и правилами доступа/хранения.
- `public-api` лишь агрегирует и маршрутизирует, но не “придумывает” доменные правила.

## SOLID

### SRP (Single Responsibility)
- Один модуль/класс/пакет = одна ответственность.
- На уровне сервиса: один сервис = один доменный контекст.

### OCP (Open/Closed)
- Добавляем новое поведение расширением (новые реализации/модули), а не переписыванием старого.
- Используйте интерфейсы/полиморфизм там, где действительно есть вариативность.

### LSP (Liskov Substitution)
- Реализации интерфейса должны строго соблюдать контракт (ошибки, семантика, ограничения).

### ISP (Interface Segregation)
- Интерфейсы — узкие и потребитель-ориентированные.
- Лучше 3 маленьких интерфейса, чем 1 “толстый”.

### DIP (Dependency Inversion)
- Высокоуровневая бизнес-логика зависит от абстракций.
- Инфраструктура реализует абстракции и подключается при сборке приложения (composition root).

## DRY (Don’t Repeat Yourself)

Правила:
- Любая повторяющаяся логика должна иметь единственный источник правды.
- Общий код выносится в `libs/` (по языкам и назначению).
- Общие контракты — в `proto/`, а не “скопированные структуры” по сервисам.

Сигналы нарушения DRY:
- одинаковые middleware/логгеры/клиенты очередей в каждом сервисе,
- копипаст SQL/DTO/валидаций,
- несколько “почти одинаковых” proto-сообщений для одной сущности.

## KISS (Keep It Simple, Stupid)

Правила:
- Предпочитайте простые конструкции и очевидные решения.
- Избегайте over-engineering и “архитектуры на вырост”.
- Если абстракция не снижает сложность, а повышает — не вводить.

Практика:
- В transport-слое минимум логики.
- В домене — прозрачные правила без “магии”.
- В инфраструктуре — один способ подключения/конфигурирования (не 5 разных клиентов).

## Clean Architecture

Правила слоёв:
- зависимости направлены внутрь: `transport -> application -> domain`, а инфраструктура “снаружи”.
- домен не импортирует:
    - HTTP/gRPC фреймворки,
    - драйверы БД/ORM,
    - клиентов очередей,
    - конкретные SDK внешних сервисов.

Практика:
- Domain задаёт интерфейсы (порты).
- Infrastructure реализует интерфейсы (адаптеры).
- Composition root (обычно `main`/`app`) склеивает зависимости.

Ключевой критерий:
- бизнес-логику можно запустить без реальной БД/очереди, подставив реализации интерфейсов.

