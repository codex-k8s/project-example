# Общий чек-лист перед PR (обязателен для ИИ-агента)

Этот чек-лист проверяет соответствие всем правилам из `docs/design-guidelines/{common,go,vue}/*.md`.
Чек лист используется как self-check перед созданием PR, отмечать в этом файле не нужно, как и дублировать чек-лист в PR/описание задачи.
Достаточно в PR/описании задачи указать, что чек-лист выполнен, сколько пунктов релевантно и что все они выполнены.

## Self-check перед PR
- [ ] Не размыты доменные границы: один сервис = один bounded context; нет “service-олигарха”; edge (`external|staff`) остаётся thin-edge.
- [ ] Frontend/приложения (если затрагиваются) размещены в `services/external/*` или `services/staff/*` по аудитории.
- [ ] Нет shared DB между сервисами; владелец данных один; доступ другим — через API/события.
- [ ] Контракты меняются через `proto/` (single source of truth), без копипаста; совместимость соблюдена или есть явное версионирование (`v2`/план миграции); CI для proto (lint+breaking) учитывается.
- [ ] Сервис в правильной зоне `services/<zone>/<service-name>/`, имя `kebab-case`; у сервиса есть краткий `README.md`; новый/изменённый сервис отражён в `services.yaml` (если применимо).
- [ ] Протокол выбран по назначению: internal sync=gRPC; внешний API=HTTP/REST (и/или WS); async=RabbitMQ.
- [ ] Если есть WebSocket: контракт сообщений описан в `api/server/asyncapi.yaml`.
- [ ] Сервис “эксплуатируем”: `/health/livez`, `/health/readyz` (критичные зависимости), `/metrics` (если сервис/endpoint затрагивается).
- [ ] Сборка/окружения: есть Dockerfile и воспроизводимая сборка; dev/staging/prod отличаются только конфигом; `services/dev/*` не включаются в prod.
- [ ] Конфиг/секреты: только env/конфиг; секреты не коммитятся/не хардкодятся; в логах нет секретов/PII.

## Инфраструктура (если затрагивается)
- [ ] Postgres: схема меняется только миграциями; SQL с placeholders; транзакции минимальны; нет бизнес-логики в SQL; DB доступ только в repo; repo возвращает доменную семантику ошибок.
- [ ] Миграции Postgres: `cmd/cli/migrations/*.sql` (goose); новые изменения — новой миграцией (не “править историю”).
- [ ] Redis: не source of truth; TTL по умолчанию; ключи `<domain>:<entity>:<id>`; единый формат сериализации; учтён cache stampede (если нужно); Redis Pub/Sub не для критичных задач.
- [ ] RabbitMQ: схема+версия сообщения; идемпотентность; QoS/prefetch; ack/nack; контролируемые ретраи (лимит+DLQ); publisher confirms (важное); `message_id`/correlation-id (цепочки).
- [ ] Внешние API: отдельный клиент; таймауты; ретраи (backoff+jitter) + уважение rate limits; ошибки -> доменная семантика; payload/PII не логируются.

## Observability (если сервис/входы/выходы затрагиваются)
- [ ] Логи структурированные; уровни по назначению; `trace_id` обязателен (и корреляция `span_id`/`request_id`/`message_id` по ситуации); нет секретов/PII; вход логируется в middleware/interceptor (без шума/дублей).
- [ ] Трейсинг: вход создаёт/продолжает trace; контекст прокидывается; внешние вызовы (DB/gRPC/HTTP/queue) в отдельных спанах; имена/атрибуты по конвенциям; sampling задаётся окружением.
- [ ] Метрики: `/metrics`; минимум — ops/errors/latency(hist)/runtime; лейблы низкой кардинальности; единый нейминг; exemplars — если возможно.

## Ошибки (обязательное, если есть `error`/API/параллельность)
- [ ] Нет “универсальной AppError” (status/code/details/...) как основного механизма.
- [ ] Ошибки возвращаются наверх; не “глотаются” без причины; контекст добавляется только полезным `%w` (без “пустых” обёрток).
- [ ] Ниже границы нет логирования ошибок (кроме явно разрешённых временных исключений под флагом); ошибка логируется один раз на границе.
- [ ] Typed errors используются только когда нужно ветвление/структурные детали; они централизованы (напр. `internal/domain/errs`) и их мало; проверка через `errors.As/Is`; нет сравнения по строкам/`reflect`.
- [ ] Transport handler’ы тонкие: не форматируют ответ и не выбирают коды; делают `return err`.
- [ ] HTTP (если есть): OpenAPI/schema validation только в middleware; есть единый HTTP error handler; ответы стабильные и безопасные; в prod нет утечки внутренних деталей; `context.Canceled` не логируется как ошибка.
- [ ] HTTP (Go): OpenAPI-спека в `api/server/api.yaml`; request validation через `github.com/getkin/kin-openapi`; handler’ы не повторяют schema/type validation.
- [ ] gRPC (если есть): настроены interceptors (error mapping + recovery); доменные ошибки маппятся в корректные `codes.*`; `message` безопасный; ожидаемые ошибки не логируются как `error`.
- [ ] Параллельность (если есть): есть fan-in (обычно `errgroup.WithContext`); ошибки агрегируются до возврата; panic в важных goroutine перехватывается (`recover()` -> `error`); логирование после агрегации.
- [ ] Фоллбэк/деградация (если есть): при “успехе с деградацией” ошибка не прокидывается наверх; лог в месте решения, с `fallback/degraded` + причина + компонент, без дублей.
- [ ] Любые исключения из правил применены строго по оговорённым условиям (временные — под флагом и с обязательным удалением).

## Библиотеки и контракты (если затрагивается `libs/` или `proto/`)
- [ ] Вынос в `libs/` оправдан (>= 2 сервисов/единый стандарт); библиотека не “бог-утилита”; публичный API минимален/стабилен; зависимости осознанные; есть README (контракты + минимальные примеры); правила ошибок и совместимости ясны.
- [ ] Breaking changes в библиотеках/контрактах сделаны только с планом миграции; по возможности есть период совместимости old+new; изменения зафиксированы (changelog/ADR, если принято).
- [ ] Protobuf: package версионирован (`*.v1`); номера полей не переиспользуются; семантика существующих полей не меняется; удаление через `deprecate -> migrate -> remove`; все публичные сообщения/поля задокументированы комментариями.
- [ ] Доменные модели не “генерируются из proto”: они живут в `internal/domain/types/{entity,enum,mixin,query,value}/*`, а маппинг с транспортом/хранилищем делается в `internal/domain/casters/*`.

## Репозитории и SQL (если есть Postgres)
- [ ] Интерфейсы repo: `internal/domain/repository/<model>/repository.go`; реализация: `internal/repository/postgres/<model>/repository.go`.
- [ ] Все SQL: `internal/repository/postgres/<model>/sql/*.sql` (по файлу на запрос), подключение только `//go:embed`, без SQL-строк в Go.
- [ ] SQL имеет имена `-- name: <model>__<operation> :one|:many|:exec`; сложные запросы допускают шаблонизацию в `.sql` с явными параметрами.

## Frontend (Vue) (если затрагивается)
- [ ] Используется стек: Vue 3 + TypeScript + Pinia + Axios + Vite (`@vitejs/plugin-vue`) + `vite-plugin-pwa` + `vue-router` + `vue-i18n` + `vue3-cookies`.
- [ ] Приложение лежит в правильной зоне: `services/external/*` (public) или `services/staff/*` (staff/admin).
- [ ] Структура `src/` выдержана: `src/app`, `src/router`, `src/i18n`, `src/shared/{api,ui,lib}`, `src/features`, `src/pages` (и опц. `src/widgets`).
- [ ] HTTP: нет прямых вызовов `axios` из компонентов/страниц; есть единый axios instance + интерсепторы + нормализация ошибок в `shared/api`.
- [ ] Ошибки: UI не показывает сырые сообщения backend; ошибки маппятся в безопасные i18n ключи; отмена запросов не считается UI ошибкой.
- [ ] Pinia: store по фичам; side-effects в actions/feature services; нет “одного глобального store на всё”.
- [ ] i18n: UI тексты через ключи; форматирование централизовано.
- [ ] Cookies: доступ через единый адаптер/обёртку; нет “магических строк” и утечки чувствительных данных.
- [ ] PWA: кеширование не ломает auth и не выдаёт устаревшие API данные как актуальные; предусмотрен UX обновления версии.
- [ ] Если код нужен >= 2 приложениям — он вынесен в `libs/{vue|ts|js}` (без доменной бизнес-логики приложения).

## Комментарии (если затрагивается Go-код)
- [ ] Комментарии на английском (если не публичная внешняя библиотека).
- [ ] Экспортируемые пакеты имеют package comment (`doc.go` или начало файла) и он начинается с имени пакета.
- [ ] Экспортируемые типы/функции/методы имеют комментарии (начинаются с имени; описывают смысл/ограничения; не повторяют сигнатуру).
- [ ] Экспортируемые поля прокомментированы, если смысл неочевиден/это контракт/доменная семантика (очевидные `ID`, `CreatedAt` можно без комментария).
- [ ] Комментарии объясняют “почему”, фиксируют инварианты/компромиссы/временные решения; нет устаревших/вводящих в заблуждение комментариев.
- [ ] `TODO` только с причиной и желательно ссылкой на задачу; `FIXME` только для явно временного/некорректного решения.

## Definition of Done (PR соответствует стандарту, если)
- [ ] Выполнены все релевантные пункты выше (включая “если применимо”).
- [ ] Не нарушены принципы DDD/SOLID/DRY/KISS/Clean Architecture и требования к сервисам/инфраструктуре/observability.
- [ ] Ошибки/контракты/логирование/трейсы/метрики не создают новый публичный контракт “случайно” и не ухудшают безопасность.
