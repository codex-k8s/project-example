# Наблюдаемость в project-example

## Общие правила

- Все сообщения логов и текстов ошибок — **только на английском**.
- Логи пишутся в stdout/stderr контейнеров и читаются через `kubectl logs`.
- Для health‑проверок используются отдельные HTTP‑эндпоинты.

## Django (`django_backend`)

- Логи:
  - сконфигурированы через стандартный `LOGGING` в `config/settings.py`;
  - выводятся в stdout с уровнем `INFO`/`DEBUG` в зависимости от `DEBUG`.
- Health:
  - `/health/livez/` — быстрая проверка процесса;
  - `/health/readyz/` — проверка готовности приложения.

При работе с кодом:

- используйте `logging.getLogger(__name__)` и лаконичные сообщения;
- не логируйте чувствительные данные (пароли, токены).

## Go (`chat_backend`)

- Логи:
  - стандартный пакет `log`, вывод в stdout;
  - сообщения на английском, без лишнего шума;
- Health:
  - `GET /health/livez` — просто `{"status":"ok"}`;
  - `GET /health/readyz` — проверяет `db.Ping()` и `redis.Ping()`.

Рекомендуется:

- группировать события по уровню (`info`, `error`, `debug`)
  через префиксы и структурированные сообщения;
- в будущих расширениях добавить OTEL‑инструментирование
  и метрики (например, latency API, количество ошибок).

## Jaeger и трейсы

Манифест `deploy/jaeger.yaml` разворачивает:

- ConfigMap с конфигурацией OTEL;
- Deployment Jaeger (collector + query) в in‑memory режиме;
- Service с портами:
  - `16686` — Web UI;
  - `4317` — OTLP gRPC;
  - `4318` — OTLP HTTP.

В текущем примере сервисы не отправляют трейсы,
но Jaeger готов к приёму данных — это отправная точка для
интеграции OTEL в Go/Django в будущих изменениях.

## Метрики

Специализированного стека метрик (Prometheus/Grafana) в примере нет.
Рекомендуемый подход при расширении:

- экспортировать `/metrics` (Prometheus формат) в сервисах;
- добавить соответствующие Deploy/Service для Prometheus/Grafana;
- использовать общую библиотеку метрик (например, в `libs/go/metrics`).

